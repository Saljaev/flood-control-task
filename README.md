# Задание на стажировку
## Содержание
- [Задание](#что-нужно-сделать)
  - [Дополнительные требования](#необязательно-но-было-бы-круто)
- [Реализация](#реализация)
- [Структура проекта](#структура-проекта)
## Что нужно сделать

Реализовать интерфейс с методом для проверки правил флуд-контроля. Если за последние N секунд вызовов метода Check будет больше K, значит, проверка на флуд-контроль не пройдена.

- Интерфейс FloodControl располагается в файле main.go.

- Флуд-контроль может быть запущен на нескольких экземплярах приложения одновременно, поэтому нужно предусмотреть общее хранилище данных. Допустимо использовать любое на ваше усмотрение. 

## Необязательно, но было бы круто

Хорошо, если добавите поддержку конфигурации итоговой реализации. Параметры — на ваше усмотрение.

## Реализация
Для хранения данных был выбран `Redis`, так как нужна максимальная скорость записи, обработки и чтения данных.

Моя идея - использование отсортированного списка в виде структуры хранения, чтобы свести к минимуму затраты на запросы к хранилищу. Я храню ключ,
которым является `ID` пользователя, а в виде значения использую количество его запросов. Преимуществом такого подхода является работа с данными за `O(log(N)`.

Если пользователь обратился в первый раз
за промежуток времени `N`, то я устанавливаю `Expires` со значением `N` на список с его `ID`. Таким образом результат, который вернёт функция
`ZADD` или `ZINCRBY` и будет являться `K` запросов пользователя за `N` секунд.

Ограничения на параметры флуда, а именнно количество запросов и интервал времени `N` находятся в файле `config.yaml` в переменных
`request_count` и `interval` соответственно. Моя реализация подразумевает какой-то сервис авторизации, который будет записывать в header
`user_id`, поэтому для проверки нужно указать этот параметр в заголовке запроса. Для проверки работы достаточно прописать `docker-compose up --build` и кинуть запрос на `localhost:8080`.



*Файл main.go переместил в cmd/backend/, а интерфейс FloodControl разместил в flood-control/handler, чтобы находился по месту использования.*
## Структура проекта
```
flood-control-task
├── cmd
│   └── backend
│       └── main.go <- Точка входа в приложение
├── config
│   └── config.yaml <- Конфигурация приложения
├── internal
│   ├── app
│   │   └── app.go <- Код инициализации
│   ├── config
│   │   └── config.go <- Код загрузки и получения данных с конфига
│   ├── flood-control
│   │   ├── check.go <- Реализация метода Check
│   │   ├── handler <- Мок обработчика запросов, здесь находится интерфейс FloodControl
│   │   └── api-imitaion <- Имитация ответа
│   ├── models
│   │   └── user-rate.go <- Модель запросов пользователей
│   └── usecase
│       └── redis-rate.go <- Методы запросов пользователей
├── docker-compose.yaml
├── Dockerfile
└── .env <- Переменные окружения для docker
```
